"""Lights Out — Stream Deck puzzle game.

Toggle lights to turn them all OFF! Pressing a button flips it
and its four neighbours (up/down/left/right).
All 32 buttons (4x8 grid) are the game field.

Levels are generated by random presses from an all-off state,
guaranteeing every puzzle is solvable.

Usage:
    uv run python scripts/lights_game.py
"""

import os
import random
import struct
import sys
import tempfile
import threading
import time
import wave

from PIL import Image, ImageDraw, ImageFont
from StreamDeck.DeviceManager import DeviceManager
from StreamDeck.ImageHelpers import PILHelper

import sound_engine
import scores

# ── config ───────────────────────────────────────────────────────────
ROWS = 4
COLS = 8
SIZE = (96, 96)
FONT_PATH = "/System/Library/Fonts/Helvetica.ttc"
SFX_VOLUME = 0.3

# Number of random presses per level (guarantees solvability)
LEVEL_PRESSES = {1: 3, 2: 5, 3: 7, 4: 10, 5: 15}
MAX_LEVEL = 5

# Bright ON colors per level
LEVEL_COLORS = {
    1: "#facc15",  # yellow
    2: "#22d3ee",  # cyan
    3: "#e879f9",  # magenta
    4: "#fb923c",  # orange
    5: "#34d399",  # emerald
}
OFF_COLOR = "#111827"

# ── grid helpers ─────────────────────────────────────────────────────


def pos_to_rc(pos: int) -> tuple[int, int]:
    return pos // COLS, pos % COLS


def rc_to_pos(row: int, col: int) -> int:
    return row * COLS + col


def get_neighbours(pos: int) -> list[int]:
    """Return list of positions affected by pressing pos (self + 4 neighbours)."""
    r, c = pos_to_rc(pos)
    result = [pos]
    if r > 0:
        result.append(rc_to_pos(r - 1, c))
    if r < ROWS - 1:
        result.append(rc_to_pos(r + 1, c))
    if c > 0:
        result.append(rc_to_pos(r, c - 1))
    if c < COLS - 1:
        result.append(rc_to_pos(r, c + 1))
    return result


# ── duke nukem voice lines ──────────────────────────────────────────
PEON_DIR = os.path.expanduser("~/.claude/hooks/peon-ping/packs")
VOICES = {
    "start": [
        "duke_nukem/sounds/HailToTheKing.wav",
        "duke_nukem/sounds/Groovy.wav",
        "duke_nukem/sounds/OnIt.wav",
        "duke_nukem/sounds/ShowMeSomething.wav",
    ],
    "solve": [
        "duke_nukem/sounds/HellYeah.wav",
        "duke_nukem/sounds/HotDamnBaby.wav",
        "duke_nukem/sounds/KaboomBaby.wav",
        "duke_nukem/sounds/LastOneStanding.wav",
    ],
    "levelup": [
        "duke_nukem/sounds/BallsOfSteel.wav",
        "duke_nukem/sounds/HotDamnGroove.wav",
        "duke_nukem/sounds/LegendsNeverDie.wav",
    ],
    "newbest": [
        "duke_nukem/sounds/DaddysHere.wav",
        "duke_nukem/sounds/KickAssChewGum.wav",
        "duke_nukem/sounds/MurderTime.wav",
    ],
}

_last_voice_time: float = 0
VOICE_COOLDOWN = 4.0


def play_voice(event: str):
    """Play a random Duke voice line — with cooldown to avoid spam."""
    global _last_voice_time
    now = time.monotonic()
    if now - _last_voice_time < VOICE_COOLDOWN:
        return
    paths = VOICES.get(event, [])
    if not paths:
        return
    random.shuffle(paths)
    for rel in paths:
        full = os.path.join(PEON_DIR, rel)
        if os.path.exists(full):
            _last_voice_time = now
            sound_engine.play_voice(full)
            return


def _font(size: int) -> ImageFont.FreeTypeFont:
    try:
        return ImageFont.truetype(FONT_PATH, size)
    except OSError:
        return ImageFont.load_default()


# ── 8-bit sound engine ──────────────────────────────────────────────
SAMPLE_RATE = 22050
_sfx_cache: dict[str, str] = {}
_sfx_dir: str = ""


def _square(freq: float, dur: float, vol: float = 1.0, duty: float = 0.5) -> list[float]:
    samples = []
    n = int(SAMPLE_RATE * dur)
    for i in range(n):
        if freq == 0:
            samples.append(0)
        else:
            t = i / SAMPLE_RATE
            phase = (t * freq) % 1.0
            val = vol if phase < duty else -vol
            env = min(1.0, i / (SAMPLE_RATE * 0.003))
            tail = max(0.0, 1.0 - (i / n) * 0.8)
            samples.append(val * env * tail)
    return samples


def _triangle(freq: float, dur: float, vol: float = 1.0) -> list[float]:
    samples = []
    n = int(SAMPLE_RATE * dur)
    for i in range(n):
        if freq == 0:
            samples.append(0)
        else:
            t = i / SAMPLE_RATE
            phase = (t * freq) % 1.0
            val = (4 * abs(phase - 0.5) - 1) * vol
            env = min(1.0, i / (SAMPLE_RATE * 0.003))
            tail = max(0.0, 1.0 - (i / n) * 0.6)
            samples.append(val * env * tail)
    return samples


def _noise(dur: float, vol: float = 0.5) -> list[float]:
    samples = []
    n = int(SAMPLE_RATE * dur)
    for i in range(n):
        env = max(0, 1.0 - (i / n) * 6)
        samples.append(random.uniform(-vol, vol) * env)
    return samples


def _merge(*lists: list[float]) -> list[float]:
    length = max(len(a) for a in lists)
    result = []
    for i in range(length):
        s = sum(a[i] if i < len(a) else 0 for a in lists)
        result.append(max(-0.95, min(0.95, s)))
    return result


def _write_wav(path: str, samples: list[float]):
    with wave.open(path, "w") as w:
        w.setnchannels(1)
        w.setsampwidth(2)
        w.setframerate(SAMPLE_RATE)
        for s in samples:
            s = max(-0.95, min(0.95, s))
            w.writeframes(struct.pack("<h", int(s * 32767)))


def _generate_sfx():
    """Generate all game sound effects as WAV files."""
    global _sfx_dir
    _sfx_dir = tempfile.mkdtemp(prefix="lights-sfx-")
    v = SFX_VOLUME

    # TOGGLE — quick blip (E5 -> G5, short and snappy)
    s = _square(659, 0.03, v * 0.4, 0.25) + _square(784, 0.02, v * 0.3, 0.25)
    _write_wav(os.path.join(_sfx_dir, "toggle.wav"), s)
    _sfx_cache["toggle"] = os.path.join(_sfx_dir, "toggle.wav")

    # SOLVE — victory fanfare (C5 -> E5 -> G5 -> C6)
    s = (_triangle(523, 0.1, v * 0.5) +
         _triangle(659, 0.1, v * 0.55) +
         _triangle(784, 0.1, v * 0.6) +
         _triangle(1047, 0.3, v * 0.7))
    _write_wav(os.path.join(_sfx_dir, "solve.wav"), s)
    _sfx_cache["solve"] = os.path.join(_sfx_dir, "solve.wav")

    # LEVELUP — ascending arpeggio (E4 -> G#4 -> B4 -> E5)
    s = (_square(330, 0.06, v * 0.4, 0.25) +
         _square(415, 0.06, v * 0.45, 0.25) +
         _square(494, 0.06, v * 0.5, 0.25) +
         _triangle(659, 0.15, v * 0.6))
    _write_wav(os.path.join(_sfx_dir, "levelup.wav"), s)
    _sfx_cache["levelup"] = os.path.join(_sfx_dir, "levelup.wav")

    # START — power-up chime (C4 -> E4 -> G4 -> C5)
    s = (_triangle(262, 0.06, v * 0.4) +
         _triangle(330, 0.06, v * 0.45) +
         _triangle(392, 0.06, v * 0.5) +
         _triangle(523, 0.12, v * 0.6))
    _write_wav(os.path.join(_sfx_dir, "start.wav"), s)
    _sfx_cache["start"] = os.path.join(_sfx_dir, "start.wav")

    # NEWBEST — triumphant jingle (C5 -> E5 -> G5 -> B5 -> C6)
    s = (_triangle(523, 0.08, v * 0.5) +
         _triangle(659, 0.08, v * 0.55) +
         _triangle(784, 0.08, v * 0.6) +
         _triangle(988, 0.08, v * 0.65) +
         _triangle(1047, 0.3, v * 0.7))
    _write_wav(os.path.join(_sfx_dir, "newbest.wav"), s)
    _sfx_cache["newbest"] = os.path.join(_sfx_dir, "newbest.wav")


def play_sfx(name: str):
    """Play sound non-blocking via afplay."""
    wav = _sfx_cache.get(name)
    if wav and os.path.exists(wav):
        sound_engine.play_sfx_file(wav)


def cleanup_sfx():
    if _sfx_dir and os.path.isdir(_sfx_dir):
        import shutil
        shutil.rmtree(_sfx_dir, ignore_errors=True)


# ── renderers ────────────────────────────────────────────────────────

def _text_tile(bg: str, lines: list[tuple[str, int, str, int]], size=SIZE) -> Image.Image:
    """Render a tile with vertically-stacked text lines.
    Each line: (text, font_size, fill_color, y_position).
    """
    img = Image.new("RGB", size, bg)
    d = ImageDraw.Draw(img)
    for txt, fsz, clr, y in lines:
        d.text((48, y), txt, font=_font(fsz), fill=clr, anchor="mt")
    return img


def render_light_on(color: str, size=SIZE) -> Image.Image:
    """Bright lit tile with glow effect."""
    img = Image.new("RGB", size, color)
    d = ImageDraw.Draw(img)
    d.rounded_rectangle([12, 12, 84, 84], radius=8, fill=color)
    d.ellipse([28, 28, 68, 68], fill="#ffffff40")
    d.rounded_rectangle([4, 4, 92, 92], radius=10, outline="white", width=2)
    return img


def render_light_off(size=SIZE) -> Image.Image:
    """Dark tile — light is off."""
    img = Image.new("RGB", size, OFF_COLOR)
    d = ImageDraw.Draw(img)
    d.rounded_rectangle([6, 6, 90, 90], radius=8, outline="#1f2937", width=2)
    d.ellipse([40, 40, 56, 56], fill="#1f2937")
    return img


def render_celebration(color: str, char: str, size=SIZE) -> Image.Image:
    """Celebration tile — colored with star/sparkle."""
    img = Image.new("RGB", size, color)
    d = ImageDraw.Draw(img)
    d.text((48, 48), char, font=_font(36), fill="white", anchor="mm")
    return img


# ── game logic ───────────────────────────────────────────────────────

class LightsGame:
    def __init__(self, deck):
        self.deck = deck
        self.best = scores.load_best("lights", default=999)
        self.level = 1
        self.moves = 0
        self.total_moves = 0  # cumulative across all levels
        self.running = False
        self.celebrating = False
        self.lock = threading.Lock()
        self._timers: list[threading.Timer] = []

        # Board: 32 booleans — True = light ON
        self.grid: list[bool] = [False] * (ROWS * COLS)

        # Pre-render static images
        self.img_off = render_light_off()
        self.img_hud_empty = Image.new("RGB", SIZE, OFF_COLOR)

    def set_key(self, pos: int, img: Image.Image):
        native = PILHelper.to_native_key_format(self.deck, img)
        with self.deck:
            self.deck.set_key_image(pos, native)

    def _cancel_all_timers(self):
        """Cancel all pending timers for clean state transitions."""
        for t in self._timers:
            t.cancel()
        self._timers.clear()

    def _on_color(self) -> str:
        return LEVEL_COLORS.get(self.level, "#facc15")

    def _lights_on_count(self) -> int:
        return sum(1 for lit in self.grid if lit)

    def _is_solved(self) -> bool:
        return not any(self.grid)

    # ── idle / start screen ──────────────────────────────────────────

    def show_idle(self):
        """Show start screen — title, best, info, and start button."""
        self._cancel_all_timers()
        self.running = False
        self.celebrating = False

        # Row 0: title + info
        self.set_key(0, _text_tile("#111827", [
            ("LIGHTS", 16, "#facc15", 26), ("OUT", 18, "#fbbf24", 48)]))
        best_label = str(self.best) if self.best < 999 else "--"
        self.set_key(1, _text_tile("#111827", [
            ("BEST", 14, "#9ca3af", 20), (best_label, 28, "#34d399", 48)]))
        self.set_key(2, _text_tile("#111827", [
            ("TURN", 13, "#9ca3af", 22), ("ALL", 13, "#9ca3af", 40),
            ("OFF!", 13, "#facc15", 58)]))
        for k in range(3, 8):
            self.set_key(k, self.img_hud_empty)

        # Rows 1-3: dark grid + start button at 20
        for k in range(8, 32):
            if k == 20:
                img = Image.new("RGB", SIZE, "#065f46")
                d = ImageDraw.Draw(img)
                d.text((48, 30), "LIGHTS", font=_font(14), fill="white", anchor="mm")
                d.text((48, 48), "OUT", font=_font(16), fill="#34d399", anchor="mm")
                d.text((48, 68), "START", font=_font(12), fill="#6ee7b7", anchor="mm")
                self.set_key(k, img)
            else:
                self.set_key(k, self.img_off)

    # ── board rendering ──────────────────────────────────────────────

    def _render_board(self):
        """Redraw all 32 game tiles based on grid state."""
        color = self._on_color()
        img_on = render_light_on(color)
        for pos in range(ROWS * COLS):
            self.set_key(pos, img_on if self.grid[pos] else self.img_off)

    def _render_cell(self, pos: int):
        """Redraw a single cell."""
        if self.grid[pos]:
            self.set_key(pos, render_light_on(self._on_color()))
        else:
            self.set_key(pos, self.img_off)

    # ── level generation ─────────────────────────────────────────────

    def _generate_level(self):
        """Generate a solvable puzzle by random presses from all-off state."""
        self.grid = [False] * (ROWS * COLS)
        presses = LEVEL_PRESSES.get(self.level, 15)
        positions = random.sample(range(ROWS * COLS), min(presses, ROWS * COLS))
        for pos in positions:
            for nb in get_neighbours(pos):
                self.grid[nb] = not self.grid[nb]
        # Edge case: if all lights ended up OFF, add one more press
        if not any(self.grid):
            extra = random.randint(0, ROWS * COLS - 1)
            for nb in get_neighbours(extra):
                self.grid[nb] = not self.grid[nb]

    # ── game start / level transitions ───────────────────────────────

    def start_game(self):
        """Start a new game from level 1."""
        self._cancel_all_timers()
        with self.lock:
            self.level = 1
            self.moves = 0
            self.total_moves = 0
            self.running = True
            self.celebrating = False

        play_sfx("start")
        play_voice("start")
        self._generate_level()
        self._render_board()

    def _start_next_level(self):
        """Advance to the next level."""
        with self.lock:
            self.level = min(self.level + 1, MAX_LEVEL)
            self.moves = 0
            self.celebrating = False

        play_sfx("levelup")
        play_voice("levelup")
        self._generate_level()
        self._render_board()

    # ── toggle logic ─────────────────────────────────────────────────

    def _toggle(self, pos: int):
        """Toggle a cell and its neighbours."""
        for nb in get_neighbours(pos):
            self.grid[nb] = not self.grid[nb]

    # ── celebration animation ────────────────────────────────────────

    def _celebrate_solve(self):
        """Run celebration animation when puzzle is solved."""
        color = self._on_color()
        stars = ["\u2605", "\u2726", "\u2605", "\u2726"]

        # Wave: ripple from center outward
        center_r, center_c = ROWS // 2, COLS // 2
        max_dist = max(ROWS, COLS)
        for dist in range(max_dist + 1):
            if not self.celebrating:
                return
            for r in range(ROWS):
                for c in range(COLS):
                    if abs(r - center_r) + abs(c - center_c) == dist:
                        pos = rc_to_pos(r, c)
                        self.set_key(pos, render_celebration(
                            color, random.choice(stars)))
            time.sleep(0.08)

        time.sleep(0.3)
        if not self.celebrating:
            return

        # Clear to dark
        for pos in range(ROWS * COLS):
            self.set_key(pos, self.img_off)
        time.sleep(0.1)
        if not self.celebrating:
            return

        # Show results on center tiles
        self.set_key(18, _text_tile("#065f46", [
            ("ALL", 16, "white", 28), ("OFF!", 18, "#34d399", 50)]))
        self.set_key(19, _text_tile("#111827", [
            ("MOVES", 14, "#9ca3af", 20),
            (str(self.total_moves), 28, "#60a5fa", 48)]))

        is_new_best = self.total_moves < self.best
        if is_new_best:
            self.best = self.total_moves
            scores.save_best("lights", self.best)
            self.set_key(21, _text_tile("#111827", [
                ("NEW", 16, "#fbbf24", 24), ("BEST!", 20, "#fbbf24", 48)]))
            play_sfx("newbest")
            play_voice("newbest")
        else:
            best_label = str(self.best) if self.best < 999 else "--"
            self.set_key(21, _text_tile("#111827", [
                ("BEST", 14, "#9ca3af", 20), (best_label, 24, "#34d399", 48)]))
            play_voice("solve")

        # Key 20: next level or restart
        if self.level < MAX_LEVEL:
            next_clr = LEVEL_COLORS.get(self.level + 1, "#facc15")
            self.set_key(20, _text_tile("#111827", [
                ("LEVEL", 14, "#9ca3af", 18),
                (str(self.level + 1), 30, next_clr, 38),
                ("READY", 12, "#6ee7b7", 74)]))
        else:
            img = Image.new("RGB", SIZE, "#065f46")
            d = ImageDraw.Draw(img)
            d.text((48, 30), "LIGHTS", font=_font(14), fill="white", anchor="mm")
            d.text((48, 48), "OUT", font=_font(16), fill="#34d399", anchor="mm")
            d.text((48, 68), "START", font=_font(12), fill="#6ee7b7", anchor="mm")
            self.set_key(20, img)

    # ── key handler ──────────────────────────────────────────────────

    def on_key(self, _deck, key: int, pressed: bool):
        if not pressed:
            return

        # Start / restart from idle
        if key == 20 and not self.running:
            self.start_game()
            return

        # Celebration state — key 20 advances or restarts
        if self.celebrating:
            if key == 20:
                self._cancel_all_timers()
                if self.level < MAX_LEVEL:
                    self._start_next_level()
                else:
                    self.show_idle()
            return

        if not self.running:
            return

        # All 32 keys are the game grid
        if key < 0 or key >= ROWS * COLS:
            return

        with self.lock:
            self._toggle(key)
            self.moves += 1
            self.total_moves += 1

            play_sfx("toggle")

            # Re-render affected cells only
            for nb in get_neighbours(key):
                self._render_cell(nb)

            # Check if solved
            if self._is_solved():
                self.celebrating = True
                play_sfx("solve")
                threading.Thread(
                    target=self._celebrate_solve, daemon=True
                ).start()


# ── main ─────────────────────────────────────────────────────────────

def main():
    decks = DeviceManager().enumerate()
    deck = None
    for d in decks:
        if d.is_visual():
            deck = d
            break

    if not deck:
        print("No Stream Deck found!")
        sys.exit(1)

    try:
        _generate_sfx()
        print("Sound effects: ON")
    except Exception:
        print("Sound effects: OFF (generation failed)")

    deck.open()
    deck.reset()
    deck.set_brightness(80)
    print(f"Connected: {deck.deck_type()} ({deck.key_count()} keys)")
    print("LIGHTS OUT! Press the center button to start.")
    print("Toggle lights to turn them ALL off. Pressing a button")
    print("flips it and its 4 neighbours (up/down/left/right).")

    game = LightsGame(deck)
    game.show_idle()
    deck.set_key_callback(game.on_key)

    try:
        threading.Event().wait()
    except KeyboardInterrupt:
        best_str = str(game.best) if game.best < 999 else "none"
        print(f"\nBye! Best: {best_str} moves")
    finally:
        game._cancel_all_timers()
        deck.reset()
        deck.close()
        cleanup_sfx()


if __name__ == "__main__":
    main()
